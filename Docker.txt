//修改ubuntu分辨率
VMware中的Ubuntu Server的控制台窗口有点儿小，使用起来不太方便，要调整控制台的窗口大小，需要修改屏幕的分辨率，修改方法如下：（参见Reference）
 1. 打开grub文件($sudo vim /etc/default/grub), 修改参数
GRUB_CMDLINE_LINUX="vga=0x317", 参数值参考下图：
Colours	640x480  800x600  1024x768  1152x864  1280x1024  1600x1200
256 色	0x301	 0x303    0x305	    0x161	  0x307      0x31C
32k 色	0x310	 0x313	  0x316	    0x162	  0x319	     0x31D
64k 色	0x311	 0x314	  0x317	    0x163	  0x31A	     0x31E
16m 色	0x312	 0x315	  0x318	    ?	      0x31B	     0x31F

$sudo update-grub
$sudo reboot

//压缩文件夹
sudo tar zcvf work.tar.gz work/
//解压缩文件
tar xzvf work.tar.gz


//安装apache
sudo apt install apache2

//主要配置文件目录： / etc / apache2 / 
//主配置文件： /etc/apache2/apache2.conf 
//其他配置片段： / etc / apache2 / conf-available /和/ etc / apache2 / conf-enabled / 
//每个站点的虚拟主机配置片段： / etc / apache2 / sites-available /和/ etc / apache2 / sites-enabled / 
//用于加载模块的配置片段： / etc / apache2 / mods-available /和/ etc / apache2 / mods-enabled / 
//Web DocumentRoot： / var / www / html / 
//日志文件（错误和访问日志）目录： / var / log / apache / 


//安装配置ssh服务
https://www.cnblogs.com/hslzju/p/5839913.html
apt install openssh-server
//修改配置文件
root@ea153153c883:/etc/ssh# 
vim /etc/ssh/sshd_config 
sshd_config 这里先修改两处：
PermitRootLogin without-password 改为 PermitRootLogin yes
#PasswordAuthentication yes 改为 PasswordAuthentication yes
//重启服务
service ssh start
//设置root密码
passwd root
//生成公钥
ssh-keygen -t rsa
//在远程机器上登录
ssh root@172.17.0.2


//设置防火墙允许端口
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw  reload


//编辑ubuntu的host文件
sudo vim /etc/hosts
192.168.56.101 howtoing.local


//Ubuntu18.04安装mysql5.7
sudo apt install mysql-server mysql-client libmysqlclient-dev
# 检查状态
sudo netstat -tap | grep mysql
#设置root密码
//mysql5.7安装完成后普通用户不能进mysql，原因：root的plugin被修改成了auth_socket，用密码登陆的plugin应该是mysql_native_password，直接用root权限登录就不用密码,修改root密码和登录验证方式：
$ sudo su
# mysql
mysql>
mysql> select user, plugin from mysql.user;
+------------------+-----------------------+
| user             | plugin                |
+------------------+-----------------------+
| root             | auth_socket           |
| mysql.session    | mysql_native_password |
| mysql.sys        | mysql_native_password |
| debian-sys-maint | mysql_native_password |
+------------------+-----------------------+
4 rows in set (0.00 sec)
mysql> update mysql.user set plugin='mysql_native_password' where user='root';
mysql> flush privileges;
mysql> exit
Bye
# exit
$ sudo /etc/init.d/mysql restart
$ mysql -uroot -p
1.3配置mysql远程登录
# 修改配置文件，注释掉bind-address = 127.0.0.1
$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
# 保存退出，然后进入mysql服务，执行授权命令：
$ mysql -uroot -p
mysql> grant all on *.* to root@'%' identified by '123456' with grant option;
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)
mysql> exit
Bye
$ sudo /etc/init.d/mysql restart

//安装mysql主从复制
https://www.cnblogs.com/gl-developer/p/6170423.html
//解决克隆server导致UUID冲突问题
https://blog.csdn.net/helloxiaozhe/article/details/81150763
//解决主从同步错误
http://www.jquerycn.cn/a_24338
//设置复制范围
# 不同步哪些数据库  
binlog-ignore-db = mysql  
binlog-ignore-db = test  
binlog-ignore-db = information_schema  
  # 只同步哪些数据库，除此之外，其他不同步  
binlog-do-db = game  

//安装nginx
sudo apt install nginx
//nginx配置
配置文件：/etc/nginx/
主程序文件：/usr/sbin/nginx
Web默认目录：/usr/share/nginx/http/
日志目录：/var/log/nginx/
//操作nginx
service nginx start
service nginx stop
//查看进程
ps -ef | grep nginx



//设置静态IP
ens33:
addresses: [192.168.1.20/24]
dhcp4: false
gateway4: 192.168.1.1
nameservers:
addresses: [192.168.1.1]
optional: true
version: 2



//Docker中国 
https://www.docker-cn.com/
//安装docker
https://blog.csdn.net/pushiqiang/article/details/78682323
//删除镜像
docker rmi 镜像ID/名称
//查看运行的容器 -a 所有 -q 显示ID
docker ps -a
//启动已被停止的容器myrunoob
docker start myrunoob
//停止运行中的容器myrunoob
docker stop myrunoob
//重启容器myrunoob
docker restart myrunoob
//删除容器
docker rm 容器ID/名称
//批量停止容器
sudo docker stop $(sudo docker ps -a -q)
//批量删除容器
sudo docker rm $(sudo docker ps -a -q)
ifconf
Commands:
    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像
    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像
    commit    Create a new image from a container's changes # 提交当前容器为新的镜像
    cp        Copy files/folders from the containers filesystem to the host path
              # 从容器中拷贝指定文件或者目录到宿主机中
    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器
    diff      Inspect changes on a container's filesystem   # 查看 docker 容器变化
    events    Get real time events from the server          # 从 docker 服务获取容器实时事件
    exec      Run a command in an existing container        # 在已存在的容器上运行命令
    export    Stream the contents of a container as a tar archive   
              # 导出容器的内容流作为一个 tar 归档文件[对应 import ]
    history   Show the history of an image                  # 展示一个镜像形成历史
    images    List images                                   # 列出系统当前镜像
    import    Create a new filesystem image from the contents of a tarball  
              # 从tar包中的内容创建一个新的文件系统映像[对应 export]
    info      Display system-wide information               # 显示系统相关信息
    inspect   Return low-level information on a container   # 查看容器详细信息
    kill      Kill a running container                      # kill 指定 docker 容器
    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]
    login     Register or Login to the docker registry server   
              # 注册或者登陆一个 docker 源服务器
    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出
    logs      Fetch the logs of a container                 # 输出当前容器日志信息
    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT
              # 查看映射端口对应的容器内部源端口
    pause     Pause all processes within a container        # 暂停容器
    ps        List containers                               # 列出容器列表
    pull      Pull an image or a repository from the docker registry server
              # 从docker镜像源服务器拉取指定镜像或者库镜像
    push      Push an image or a repository to the docker registry server
              # 推送指定镜像或者库镜像至docker源服务器
    restart   Restart a running container                   # 重启运行的容器
    rm        Remove one or more containers                 # 移除一个或者多个容器
    rmi       Remove one or more images                 
              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]
    run       Run a command in a new container
              # 创建一个新的容器并运行一个命令
    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]
    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像
    start     Start a stopped containers                    # 启动容器
    stop      Stop a running containers                     # 停止容器
    tag       Tag an image into a repository                # 给源中镜像打标签
    top       Lookup the running processes of a container   # 查看容器中运行的进程信息
    unpause   Unpause a paused container                    # 取消暂停容器
    version   Show the docker version information           # 查看 docker 版本号
    wait      Block until a container stops, then print its exit code   

容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）
-p 标记可以多次使用来绑定多个端口


//安装docker compose  官网：https://docs.docker.com/compose/install/#install-compose
sudo curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
docker-compose version 1.22.0, build f46880fe
  

//更新运行中的Docker容器重启策略	
docker update --restart=always <CONTAINER ID>

//查看容器信息
docker inspect 容器ID/名称

//创建网络 --subnet=子网段 
docker network 网络名称
docker network create --subnet=172.0.0.0/16 amnp-net

//将容器加入网络
docker network connect 网络名称 容器ID/名称 

 **************************************************************  数据卷  ****************************************************************
//创建数据卷容器(/data目录为保存数据的目录) 数据卷名称:app-data
docker run -itd -v /var/lib/mysql -v /etc/apache2 -v /etc/mysql --name dv_appdata alpine:3.8 /bin/sh


//其它容器使用数据卷容器
docker run -itd --name web1 --volumes-from dv_appdata ubuntu

//通过临时容器备份数据容器卷 
//数据容器名称：dvdata    /etc目录为数据卷容器内的保存数据的目录
//docker宿主机备份目录/container_backup
//临时容器目录/backup    ubuntu 临时容器镜像名
docker run --rm --volumes-from dvdata -v /app:/backup ubuntu tar cvf /backup/aaa.tar /etc
docker run --rm --volumes-from dvdata -v /container_backup:/backup ubuntu tar cvf /backup/backup.tar /data

//恢复数据卷容器 创建数据卷容器
docker run -v /data --name dvdata2 ubuntu
//将数据恢复到临时容器，同时恢复到数据卷容器
docker run --volumes-from dvdata2 -v /container_backup:/backup ubuntu tar xvf /backup/backup.tar



**************************************************************  NGINX  ****************************************************************
//启动nginx容器,需要事先在/home/nginx/conf/目录中建立nginx.conf文件，否则配置文件挂载不上
docker run \
 --name jhz_nginx \
 --restart=always \
 -p 8082:80 \
 -d \
 -v dv-jhz-nginx-html:/usr/share/nginx/html \
 -v dv-jhz-nginx-logs:/wwwlogs \
 -v dv-jhz-nginx-conf:/etc/nginx/conf.d \
 nginx:1.15.3-alpine \
 nginx -g 'daemon off;'

 --network amnp-net \
 --ip 172.0.0.3 \
 
//以下方法进入虚拟机控制台
docker exec -it jhz_nginx /bin/bash 


**************************************************************  mysql ****************************************************************
//启动mysql容器-linux
docker run \
 --name mmm1 \
 --restart=always \
 -p 3301:3306 \
 -d \
 -v dv-mmm1-data:/var/lib/mysql \
 -v dv-mmm1-conf:/etc/mysql \
 -e MYSQL_ROOT_PASSWORD=123456 \
 mysql:5.6

 
 --network amnp-net \
 --ip 172.0.0.4 \
 -v dv-jhz-mysql-logs:/var/log/mysql \
 



 

**************************************************************  ubuntu16 php laravel 集成部署环境 ****************************************************************

docker run \
 --name fusion_plantform \
 -p 8081:80 \
 -p 3307:3306 \
 -p 5023:22 \
 -itd  \
 ubuntu:16.04 /bin/bash
 
//进入容器内部开始安装环境
docker exec -it fusion_plantform  /bin/bash 



apt update
apt upgrade
apt clean
apt autoclean
apt autoremove

//设置字符集  可选
apt install language-pack-en-base
locale-gen en_US.UTF-8
apt install software-properties-common
LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php


//安装文本编辑器
apt install vim

//安装apache2
apt install apache2
//配置apache2 
vim /etc/apache2/apache2.conf //编辑配置文件,在空白处添加下面的配置
ServerName localhost
//启动apache2
service apache2  restart
//测试apache2 访问apache 显示 Apache2 Ubuntu Default Page
http://192.168.7.227:8081/
//查看aapche版本
Apache2 -v

//安装mysql5.7
apt install mysql-server mysql-client libmysqlclient-dev
//启动mysql报错：No directory, logging in with HOME=/ 解决办法
usermod -d /var/lib/mysql/ mysql   #第一步
ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock   #第二步
chown -R mysql:mysql /var/lib/mysql   #第三步
//后期挂载数据目录到卷的时候默认docker是由root用户操作，因此mysql用户需要加入root组才能正常访问这个目录
usermod -a -G root mysql
//登录mysql 修改远程登录
$ mysql -uroot -p
mysql> grant all on *.* to root@'%' identified by '123456' with grant option;
mysql> flush privileges;
mysql> exit
# 修改配置文件，注释掉bind-address = 127.0.0.1
vim /etc/mysql/mysql.conf.d/mysqld.cnf
//重启数据库
/etc/init.d/mysql restart
//生产环境设置数据库安全(可选)
mysql_secure_installation

//安装php7
apt install php
//安装apache的php模块
apt install libapache2-mod-php
//建立php文件 phpinfo.php
<?php
 phpinfo(); 
?>
//测试aapche和php整合结果,访问以下地址,显示php配置信息页面
http://192.168.7.227:8081/phpinfo.php
//安装php扩展
apt install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl php7.0-cli php7.0-mcrypt php7.0-mbstring php7.0-dom
apt install php-zip php7.0-xml php7.0-json php7.0-gd
//查看已经安装的php模块
php -m

//重启容器,确认各种服务正常访问
docker restart  fusion_plantform
docker exec -it fusion_plantform service apache2 restart //在容器外启动apache服务
docker exec -it fusion_plantform service mysql restart    //在容器外启动mysql服务
//将容器提交为镜像
docker commit fusion_plantform fff:1.0

//从镜像启动新容器
docker run \
 --name fff2 \
 -p 8082:80 \
 -p 3308:3306 \
 -p 5024:22 \
 -itd  \
 -v fp-apache-www:/var/www/html \
 -v fp-apache-conf:/etc/apache2 \
 -v fp-mysql-data:/var/lib/mysql \
 fff:1.0 /bin/bash
//启动服务 //在容器外启动apache服务  //在容器外启动mysql服务
docker exec -it fff2 service apache2 restart 
docker exec -it fff2 service mysql restart   

//安装composer工具
apt install composer
//下载laravel依赖
composer global require "laravel/installer"
# 修改环境变量,将laravel命令加到PATH末尾
export PATH=$PATH:~/.composer/vendor/bin
//创建测试项目 laravel5.5
composer create-project --prefer-dist laravel/laravel blog 5.5


**************************************************************  portainer  ****************************************************************
#docker容器管理UI工具
docker run -d -p 9000:9000 \
    --restart=always \
    -v /var/run/docker.sock:/var/run/docker.sock \
    --name prtainer-test \
    portainer/portainer
    



**************************************************************  k8s ****************************************************************

docker run --net=host -d gcr.io/google_containers/etcd:2.0.12 /usr/local/bin/etcd --addr=127.0.0.1:4001 --bind-addr=0.0.0.0:4001 --data-dir=/var/etcd/data
上面的镜像需要翻墙，可用下面的镜像代替
docker run --net=host -d hujian/etcd:2.0.12 /usr/local/bin/etcd --addr=127.0.0.1:4001 --bind-addr=0.0.0.0:4001 --data-dir=/var/etcd/data

docker run \
    --volume=/:/rootfs:ro \
    --volume=/sys:/sys:ro \
    --volume=/dev:/dev \
    --volume=/var/lib/docker/:/var/lib/docker:ro \
    --volume=/var/lib/kubelet/:/var/lib/kubelet:rw \
    --volume=/var/run:/var/run:rw \
    --net=host \
    --pid=host \
    --privileged=true \
    -d \
    hujian/hyperkube:v1.0.1 \
    /hyperkube kubelet --containerized --hostname-override=&quot;127.0.0.1&quot; --address=&quot;0.0.0.0&quot; --api-servers=http://localhost:8080 --config=/etc/kubernetes/manifests



kubectl apply --namespace weave -f "https://cloud.weave.works/k8s/scope.yaml?k8s-version=$(kubectl version | base64 | tr -d '\n')"












**************************************************************  jira ****************************************************************

1.pull docker 镜像： jira:7.11.1(目前的最新版本) mysql:5.7
docker pull cptactionhank/atlassian-jira-software
docker pull mysql:5.7

2.启动mysql docker实例
docker run --name jira-mysql --restart always -p 3306:3306 -v /opt/mysql_data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 #记得修改passwd

3.连接mysql
docker run -it --link jira-mysql:mysql --rm mysql:5.7 sh -c 'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'

4.创建jira数据库,并添加jira用户 【mysql操作台执行】
create database jira default character set utf8 collate utf8_bin;
CREATE USER `jira`@`%` IDENTIFIED BY 'jira';GRANT ALL ON *.* TO `jira`@`%` WITH GRANT OPTION;
alter user 'jira'@'%' identified with mysql_native_password by 'jira';

5.修改mysql事物隔离级别 【mysql操作台执行】
set global transaction isolation level read committed;
set session transaction isolation level read committed;

6.启动jira实例
docker run --detach --restart always -v /mnt_ssd/jira/confluence:/home --publish 8083:8080 cptactionhank/atlassian-jira-software

7.访问：192.168.x.x:8080 进行jira配置。配置过程略。配置完成如下图：

http://192.168.99.100:8080/secure/WelcomeToJIRA.jspa


---------------------------------------- docker swarm ---------------------------------------
1.所有节点安装docker，并启用dockerAPI
#修改/lib/systemd/system/docker.service这个文件中的参数
vim /usr/lib/systemd/system/docker.service
[Service]
ExecStart=
ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
#刷新配置
systemctl daemon-reload
#重启docker服务
systemctl restart docker


2.创建管理节点
docker swarm init --advertise-addr 192.168.50.59
返回：
Swarm initialized: current node (861zwapl4whzalbmw4j2vatlr) is now a manager.
To add a worker to this swarm, run the following command:
    docker swarm join --token SWMTKN-1-5usp4j1qhatxmjdkx5c5k3jjh2u6ku9ap8vp26ro47o62r0hdu-ds66dd57klsenzt4pp6uikiim 192.168.50.59:2375
To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.

3.查看集群节点列表
docker node ls

4.在管理节点运行
docker swarm join-token worker
To add a worker to this swarm, run the following command:
    docker swarm join --token SWMTKN-1-5usp4j1qhatxmjdkx5c5k3jjh2u6ku9ap8vp26ro47o62r0hdu-ds66dd57klsenzt4pp6uikiim 192.168.50.59:2377
#获得添加其他节点的命令


3.向集群添加被管理节点
docker swarm join --token SWMTKN-1-5usp4j1qhatxmjdkx5c5k3jjh2u6ku9ap8vp26ro47o62r0hdu-ds66dd57klsenzt4pp6uikiim 192.168.50.59:2377
This node joined a swarm as a worker.





---------------------------------- - yaml格式的pod定义文件完整内容：-----------------------------------------------
apiVersion: v1       #必选，版本号，例如v1
kind: Pod       #必选，Pod
metadata:       #必选，元数据
  name: string       #必选，Pod名称
  namespace: string    #必选，Pod所属的命名空间
  labels:      #自定义标签
    - name: string     #自定义标签名字
  annotations:       #自定义注释列表
    - name: string
spec:         #必选，Pod中容器的详细定义
  containers:      #必选，Pod中容器列表
  - name: string     #必选，容器名称
    image: string    #必选，容器的镜像名称
    imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像
    command: [string]    #容器的启动命令列表，如不指定，使用打包时使用的启动命令
    args: [string]     #容器的启动命令参数列表
    workingDir: string     #容器的工作目录
    volumeMounts:    #挂载到容器内部的存储卷配置
    - name: string     #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名
      mountPath: string    #存储卷在容器内mount的绝对路径，应少于512字符
      readOnly: boolean    #是否为只读模式
    ports:       #需要暴露的端口库号列表
    - name: string     #端口号名称
      containerPort: int   #容器需要监听的端口号
      hostPort: int    #容器所在主机需要监听的端口号，默认与Container相同
      protocol: string     #端口协议，支持TCP和UDP，默认TCP
    env:       #容器运行前需设置的环境变量列表
    - name: string     #环境变量名称
      value: string    #环境变量的值
    resources:       #资源限制和请求的设置
      limits:      #资源限制的设置
        cpu: string    #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数
        memory: string     #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数
      requests:      #资源请求的设置
        cpu: string    #Cpu请求，容器启动的初始可用数量
        memory: string     #内存清楚，容器启动的初始可用数量
    livenessProbe:     #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可
      exec:      #对Pod容器内检查方式设置为exec方式
        command: [string]  #exec方式需要制定的命令或脚本
      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port
        path: string
        port: number
        host: string
        scheme: string
        HttpHeaders:
        - name: string
          value: string
      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式
         port: number
       initialDelaySeconds: 0  #容器启动完成后首次探测的时间，单位为秒
       timeoutSeconds: 0   #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒
       periodSeconds: 0    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次
       successThreshold: 0
       failureThreshold: 0
       securityContext:
         privileged:false
    restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod
    nodeSelector: obeject  #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定
    imagePullSecrets:    #Pull镜像时使用的secret名称，以key：secretkey格式指定
    - name: string
    hostNetwork:false      #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络
    volumes:       #在该pod上定义共享存储卷列表
    - name: string     #共享存储卷名称 （volumes类型有很多种）
      emptyDir: {}     #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值
      hostPath: string     #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录
        path: string     #Pod所在宿主机的目录，将被用于同期中mount的目录
      secret:      #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部
        scretname: string  
        items:     
        - key: string
          path: string
      configMap:     #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部
        name: string
        items:
        - key: string
          path: string


---------------------------------------- yaml 创建nginx服务 v1.13.4 --------------------------------------------
{
  "kind": "Service",
  "apiVersion": "v1",
  "metadata": {
    "name": "nginx-test",
    "namespace": "default",
    "selfLink": "/api/v1/namespaces/default/services/nginx-test",
    "uid": "41aefd5e-993f-11e9-867c-000c293a12a7",
    "resourceVersion": "4849988",
    "creationTimestamp": "2019-06-28T00:54:17Z",
    "labels": {
      "k8s-app": "nginx-test"
    },
    "annotations": {
      "description": "miaoshu"
    }
  },
  "spec": {
    "ports": [
      {
        "name": "tcp-80-80-wmh99",
        "protocol": "TCP",
        "port": 80,
        "targetPort": 80,
        "nodePort": 30114
      }
    ],
    "selector": {
      "k8s-app": "nginx-test"
    },
    "clusterIP": "10.100.50.143",
    "type": "LoadBalancer",
    "sessionAffinity": "None",
    "externalTrafficPolicy": "Cluster"
  },
  "status": {
    "loadBalancer": {}
  }
}


------------------------------- yaml 创建部署 -------------------------------


https://192.168.6.154:6443/apis/apps/v1beta1/namespaces/default/deployments

apiVersion: apps/v1beta1    #API版本
kind: Deployment            #脚本类型
metadata:                   
  name: deployment-example  #部署名称
spec:
  replicas: 2               #副本数量
  revisionHistoryLimit: 10  #副本历史数量
  template:                 
    metadata:
      labels:
        app: nginx          #标签
    spec:
      containers:           
      - name: nginx         #容器名称
        image: nginx:1.10   #容器镜像及版本
        ports:              #容器端口号 
        - containerPort: 80

#指定命名空间
#